/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { EventEmitter, OnInit, Type } from '@angular/core';
import { NbCalendarYearModelService } from '../calendar-kit/services/calendar-year-model.service';
import { NbCalendarCell, NbCalendarSize, NbCalendarViewMode, NbCalendarSizeValues, NbCalendarViewModeValues } from '../calendar-kit/model';
import { NbDateService } from '../calendar-kit/services/date.service';
import { NbBooleanInput } from '../helpers';
/**
 * The basis for calendar and range calendar components.
 * Encapsulates common behavior - store calendar state and perform navigation
 * between pickers.
 * */
import * as ɵngcc0 from '@angular/core';
export declare class NbBaseCalendarComponent<D, T> implements OnInit {
    protected dateService: NbDateService<D>;
    protected yearModelService: NbCalendarYearModelService<D>;
    /**
     * Defines if we should render previous and next months
     * in the current month view.
     * */
    boundingMonth: boolean;
    /**
     * Defines active view for calendar.
     * */
    activeViewMode: NbCalendarViewMode;
    static ngAcceptInputType_activeViewMode: NbCalendarViewModeValues;
    /**
     * Minimum available date for selection.
     * */
    min: D;
    /**
     * Maximum available date for selection.
     * */
    max: D;
    /**
     * Predicate that decides which cells will be disabled.
     * */
    filter: (D: any) => boolean;
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    dayCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    monthCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    yearCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Size of the calendar and entire components.
     * Can be 'medium' which is default or 'large'.
     * */
    size: NbCalendarSize;
    static ngAcceptInputType_size: NbCalendarSizeValues;
    visibleDate: D;
    /**
     * Determines whether we should show calendar navigation or not.
     * */
    showNavigation: boolean;
    /**
     * Value which will be rendered as selected.
     * */
    date: T;
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber(): boolean;
    set showWeekNumber(value: boolean);
    protected _showWeekNumber: boolean;
    static ngAcceptInputType_showWeekNumber: NbBooleanInput;
    /**
     * Sets symbol used as a header for week numbers column
     * */
    weekNumberSymbol: string;
    /**
     * Emits date when selected.
     * */
    dateChange: EventEmitter<T>;
    constructor(dateService: NbDateService<D>, yearModelService: NbCalendarYearModelService<D>);
    ngOnInit(): void;
    get large(): boolean;
    ViewMode: typeof NbCalendarViewMode;
    setViewMode(viewMode: NbCalendarViewMode): void;
    setVisibleDate(visibleDate: D): void;
    prevMonth(): void;
    nextMonth(): void;
    prevYear(): void;
    nextYear(): void;
    prevYears(): void;
    nextYears(): void;
    navigatePrev(): void;
    navigateNext(): void;
    onChangeViewMode(): void;
    private changeVisibleMonth;
    private changeVisibleYear;
    private changeVisibleYears;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbBaseCalendarComponent<any, any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbBaseCalendarComponent<any, any>, "nb-base-calendar", never, { "boundingMonth": "boundingMonth"; "activeViewMode": "startView"; "size": "size"; "showNavigation": "showNavigation"; "showWeekNumber": "showWeekNumber"; "visibleDate": "visibleDate"; "min": "min"; "max": "max"; "filter": "filter"; "dayCellComponent": "dayCellComponent"; "monthCellComponent": "monthCellComponent"; "yearCellComponent": "yearCellComponent"; "date": "date"; "weekNumberSymbol": "weekNumberSymbol"; }, { "dateChange": "dateChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1jYWxlbmRhci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiYmFzZS1jYWxlbmRhci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmJDYWxlbmRhclllYXJNb2RlbFNlcnZpY2UgfSBmcm9tICcuLi9jYWxlbmRhci1raXQvc2VydmljZXMvY2FsZW5kYXIteWVhci1tb2RlbC5zZXJ2aWNlJztcbmltcG9ydCB7IE5iQ2FsZW5kYXJDZWxsLCBOYkNhbGVuZGFyU2l6ZSwgTmJDYWxlbmRhclZpZXdNb2RlLCBOYkNhbGVuZGFyU2l6ZVZhbHVlcywgTmJDYWxlbmRhclZpZXdNb2RlVmFsdWVzIH0gZnJvbSAnLi4vY2FsZW5kYXIta2l0L21vZGVsJztcbmltcG9ydCB7IE5iRGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jYWxlbmRhci1raXQvc2VydmljZXMvZGF0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IE5iQm9vbGVhbklucHV0IH0gZnJvbSAnLi4vaGVscGVycyc7XG4vKipcbiAqIFRoZSBiYXNpcyBmb3IgY2FsZW5kYXIgYW5kIHJhbmdlIGNhbGVuZGFyIGNvbXBvbmVudHMuXG4gKiBFbmNhcHN1bGF0ZXMgY29tbW9uIGJlaGF2aW9yIC0gc3RvcmUgY2FsZW5kYXIgc3RhdGUgYW5kIHBlcmZvcm0gbmF2aWdhdGlvblxuICogYmV0d2VlbiBwaWNrZXJzLlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50PEQsIFQ+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD47XG4gICAgcHJvdGVjdGVkIHllYXJNb2RlbFNlcnZpY2U6IE5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlPEQ+O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgKiBpbiB0aGUgY3VycmVudCBtb250aCB2aWV3LlxuICAgICAqICovXG4gICAgYm91bmRpbmdNb250aDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGFjdGl2ZSB2aWV3IGZvciBjYWxlbmRhci5cbiAgICAgKiAqL1xuICAgIGFjdGl2ZVZpZXdNb2RlOiBOYkNhbGVuZGFyVmlld01vZGU7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2FjdGl2ZVZpZXdNb2RlOiBOYkNhbGVuZGFyVmlld01vZGVWYWx1ZXM7XG4gICAgLyoqXG4gICAgICogTWluaW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqICovXG4gICAgbWluOiBEO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gYXZhaWxhYmxlIGRhdGUgZm9yIHNlbGVjdGlvbi5cbiAgICAgKiAqL1xuICAgIG1heDogRDtcbiAgICAvKipcbiAgICAgKiBQcmVkaWNhdGUgdGhhdCBkZWNpZGVzIHdoaWNoIGNlbGxzIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogKi9cbiAgICBmaWx0ZXI6IChEOiBhbnkpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGRheSBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBkYXlDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gbW9udGggY2VsbCBjb21wb25lbnQuIEhhdmUgdG8gaW1wbGVtZW50IGBOYkNhbGVuZGFyQ2VsbGAgaW50ZXJmYWNlLlxuICAgICAqICovXG4gICAgbW9udGhDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20geWVhciBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICB5ZWFyQ2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBUPj47XG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgY2FsZW5kYXIgYW5kIGVudGlyZSBjb21wb25lbnRzLlxuICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICogKi9cbiAgICBzaXplOiBOYkNhbGVuZGFyU2l6ZTtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc2l6ZTogTmJDYWxlbmRhclNpemVWYWx1ZXM7XG4gICAgdmlzaWJsZURhdGU6IEQ7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBzaG93IGNhbGVuZGFyIG5hdmlnYXRpb24gb3Igbm90LlxuICAgICAqICovXG4gICAgc2hvd05hdmlnYXRpb246IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVmFsdWUgd2hpY2ggd2lsbCBiZSByZW5kZXJlZCBhcyBzZWxlY3RlZC5cbiAgICAgKiAqL1xuICAgIGRhdGU6IFQ7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKTogYm9vbGVhbjtcbiAgICBzZXQgc2hvd1dlZWtOdW1iZXIodmFsdWU6IGJvb2xlYW4pO1xuICAgIHByb3RlY3RlZCBfc2hvd1dlZWtOdW1iZXI6IGJvb2xlYW47XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Nob3dXZWVrTnVtYmVyOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHN5bWJvbCB1c2VkIGFzIGEgaGVhZGVyIGZvciB3ZWVrIG51bWJlcnMgY29sdW1uXG4gICAgICogKi9cbiAgICB3ZWVrTnVtYmVyU3ltYm9sOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRW1pdHMgZGF0ZSB3aGVuIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPFQ+O1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlOiBOYkRhdGVTZXJ2aWNlPEQ+LCB5ZWFyTW9kZWxTZXJ2aWNlOiBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZTxEPik7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBnZXQgbGFyZ2UoKTogYm9vbGVhbjtcbiAgICBWaWV3TW9kZTogdHlwZW9mIE5iQ2FsZW5kYXJWaWV3TW9kZTtcbiAgICBzZXRWaWV3TW9kZSh2aWV3TW9kZTogTmJDYWxlbmRhclZpZXdNb2RlKTogdm9pZDtcbiAgICBzZXRWaXNpYmxlRGF0ZSh2aXNpYmxlRGF0ZTogRCk6IHZvaWQ7XG4gICAgcHJldk1vbnRoKCk6IHZvaWQ7XG4gICAgbmV4dE1vbnRoKCk6IHZvaWQ7XG4gICAgcHJldlllYXIoKTogdm9pZDtcbiAgICBuZXh0WWVhcigpOiB2b2lkO1xuICAgIHByZXZZZWFycygpOiB2b2lkO1xuICAgIG5leHRZZWFycygpOiB2b2lkO1xuICAgIG5hdmlnYXRlUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlTmV4dCgpOiB2b2lkO1xuICAgIG9uQ2hhbmdlVmlld01vZGUoKTogdm9pZDtcbiAgICBwcml2YXRlIGNoYW5nZVZpc2libGVNb250aDtcbiAgICBwcml2YXRlIGNoYW5nZVZpc2libGVZZWFyO1xuICAgIHByaXZhdGUgY2hhbmdlVmlzaWJsZVllYXJzO1xufVxuIl19