import { ElementRef, EventEmitter, OnDestroy, AfterViewInit, QueryList } from '@angular/core';
import { NbBooleanInput } from '../helpers';
import { NbLayoutScrollService } from '../../services/scroll.service';
import { NbLayoutRulerService } from '../../services/ruler.service';
import { NbListItemComponent } from './list.component';
import * as ɵngcc0 from '@angular/core';
export declare class NbScrollableContainerDimentions {
    scrollTop: number;
    scrollHeight: number;
    clientHeight: number;
}
/**
 * Infinite List Directive
 *
 * ```html
 *  <nb-list nbInfiniteList [threshold]="500" (bottomThreshold)="loadNext()">
 *    <nb-list-item *ngFor="let item of items"></nb-list-item>
 *  </nb-list>
 * ```
 *
 * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)
 *
 * Directive will notify when list scrolled up or down to a given threshold.
 * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.
 *
 * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)
 *
 * To improve UX of infinite lists, it's better to keep current page in url,
 * so user able to return to the last viewed page or to share a link to this page.
 * `nbListPageTracker` directive will help you to know, what page user currently viewing.
 * Just put it on a list, set page size and it will calculate page that currently in viewport.
 * You can [open the example](example/infinite-list/infinite-news-list.component)
 * in a new tab to check out this feature.
 *
 * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)
 *
 * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)
 *
 */
export declare class NbInfiniteListDirective implements AfterViewInit, OnDestroy {
    private elementRef;
    private scrollService;
    private dimensionsService;
    private destroy$;
    private lastScrollPosition;
    windowScroll: boolean;
    private get elementScroll();
    /**
     * Threshold after which event load more event will be emited.
     * In pixels.
     */
    threshold: number;
    /**
     * By default component observes list scroll position.
     * If set to `true`, component will observe position of page scroll instead.
     */
    set listenWindowScroll(value: any);
    static ngAcceptInputType_listenWindowScroll: NbBooleanInput;
    /**
     * Emits when distance between list bottom and current scroll position is less than threshold.
     */
    bottomThreshold: EventEmitter<any>;
    /**
     * Emits when distance between list top and current scroll position is less than threshold.
     */
    topThreshold: EventEmitter<any>;
    onElementScroll(): void;
    listItems: QueryList<NbListItemComponent>;
    constructor(elementRef: ElementRef, scrollService: NbLayoutScrollService, dimensionsService: NbLayoutRulerService);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    checkPosition({ scrollHeight, scrollTop, clientHeight }: NbScrollableContainerDimentions): void;
    private getContainerDimensions;
    private inSyncWithDom;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbInfiniteListDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbInfiniteListDirective, "[nbInfiniteList]", never, { "listenWindowScroll": "listenWindowScroll"; "threshold": "threshold"; }, { "bottomThreshold": "bottomThreshold"; "topThreshold": "topThreshold"; }, ["listItems"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtbGlzdC5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiaW5maW5pdGUtbGlzdC5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmJCb29sZWFuSW5wdXQgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IE5iTGF5b3V0U2Nyb2xsU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3Njcm9sbC5zZXJ2aWNlJztcbmltcG9ydCB7IE5iTGF5b3V0UnVsZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcnVsZXIuc2VydmljZSc7XG5pbXBvcnQgeyBOYkxpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9saXN0LmNvbXBvbmVudCc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlNjcm9sbGFibGVDb250YWluZXJEaW1lbnRpb25zIHtcbiAgICBzY3JvbGxUb3A6IG51bWJlcjtcbiAgICBzY3JvbGxIZWlnaHQ6IG51bWJlcjtcbiAgICBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbn1cbi8qKlxuICogSW5maW5pdGUgTGlzdCBEaXJlY3RpdmVcbiAqXG4gKiBgYGBodG1sXG4gKiAgPG5iLWxpc3QgbmJJbmZpbml0ZUxpc3QgW3RocmVzaG9sZF09XCI1MDBcIiAoYm90dG9tVGhyZXNob2xkKT1cImxvYWROZXh0KClcIj5cbiAqICAgIDxuYi1saXN0LWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj48L25iLWxpc3QtaXRlbT5cbiAqICA8L25iLWxpc3Q+XG4gKiBgYGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbXBsZSBpbmZpbml0ZSBsaXN0LCBpbmZpbml0ZS1saXN0L2luZmluaXRlLWxpc3Qtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIERpcmVjdGl2ZSB3aWxsIG5vdGlmeSB3aGVuIGxpc3Qgc2Nyb2xsZWQgdXAgb3IgZG93biB0byBhIGdpdmVuIHRocmVzaG9sZC5cbiAqIEJ5IGRlZmF1bHQgaXQgbGlzdGVuIHRvIHNjcm9sbCBvZiBsaXN0IG9uIHdoaWNoIGFwcGxpZWQsIGJ1dCBhbHNvIGNhbiBiZSBzZXQgdG8gbGlzdGVuIHRvIHdpbmRvdyBzY3JvbGwuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTY3JvbGwgbW9kZXMsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1zY3JvbGwtbW9kZXMuY29tcG9uZW50KVxuICpcbiAqIFRvIGltcHJvdmUgVVggb2YgaW5maW5pdGUgbGlzdHMsIGl0J3MgYmV0dGVyIHRvIGtlZXAgY3VycmVudCBwYWdlIGluIHVybCxcbiAqIHNvIHVzZXIgYWJsZSB0byByZXR1cm4gdG8gdGhlIGxhc3Qgdmlld2VkIHBhZ2Ugb3IgdG8gc2hhcmUgYSBsaW5rIHRvIHRoaXMgcGFnZS5cbiAqIGBuYkxpc3RQYWdlVHJhY2tlcmAgZGlyZWN0aXZlIHdpbGwgaGVscCB5b3UgdG8ga25vdywgd2hhdCBwYWdlIHVzZXIgY3VycmVudGx5IHZpZXdpbmcuXG4gKiBKdXN0IHB1dCBpdCBvbiBhIGxpc3QsIHNldCBwYWdlIHNpemUgYW5kIGl0IHdpbGwgY2FsY3VsYXRlIHBhZ2UgdGhhdCBjdXJyZW50bHkgaW4gdmlld3BvcnQuXG4gKiBZb3UgY2FuIFtvcGVuIHRoZSBleGFtcGxlXShleGFtcGxlL2luZmluaXRlLWxpc3QvaW5maW5pdGUtbmV3cy1saXN0LmNvbXBvbmVudClcbiAqIGluIGEgbmV3IHRhYiB0byBjaGVjayBvdXQgdGhpcyBmZWF0dXJlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5maW5pdGUgbGlzdCB3aXRoIHBhZ2VyLCBpbmZpbml0ZS1saXN0L2luZmluaXRlLW5ld3MtbGlzdC5jb21wb25lbnQpXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShJbmZpbml0ZSBsaXN0IHdpdGggcGxhY2Vob2xkZXJzIGF0IHRoZSB0b3AsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1wbGFjZWhvbGRlcnMuY29tcG9uZW50KVxuICpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZWxlbWVudFJlZjtcbiAgICBwcml2YXRlIHNjcm9sbFNlcnZpY2U7XG4gICAgcHJpdmF0ZSBkaW1lbnNpb25zU2VydmljZTtcbiAgICBwcml2YXRlIGRlc3Ryb3kkO1xuICAgIHByaXZhdGUgbGFzdFNjcm9sbFBvc2l0aW9uO1xuICAgIHdpbmRvd1Njcm9sbDogYm9vbGVhbjtcbiAgICBwcml2YXRlIGdldCBlbGVtZW50U2Nyb2xsKCk7XG4gICAgLyoqXG4gICAgICogVGhyZXNob2xkIGFmdGVyIHdoaWNoIGV2ZW50IGxvYWQgbW9yZSBldmVudCB3aWxsIGJlIGVtaXRlZC5cbiAgICAgKiBJbiBwaXhlbHMuXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBjb21wb25lbnQgb2JzZXJ2ZXMgbGlzdCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgY29tcG9uZW50IHdpbGwgb2JzZXJ2ZSBwb3NpdGlvbiBvZiBwYWdlIHNjcm9sbCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHNldCBsaXN0ZW5XaW5kb3dTY3JvbGwodmFsdWU6IGFueSk7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2xpc3RlbldpbmRvd1Njcm9sbDogTmJCb29sZWFuSW5wdXQ7XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiBkaXN0YW5jZSBiZXR3ZWVuIGxpc3QgYm90dG9tIGFuZCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhyZXNob2xkLlxuICAgICAqL1xuICAgIGJvdHRvbVRocmVzaG9sZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiBkaXN0YW5jZSBiZXR3ZWVuIGxpc3QgdG9wIGFuZCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhyZXNob2xkLlxuICAgICAqL1xuICAgIHRvcFRocmVzaG9sZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgb25FbGVtZW50U2Nyb2xsKCk6IHZvaWQ7XG4gICAgbGlzdEl0ZW1zOiBRdWVyeUxpc3Q8TmJMaXN0SXRlbUNvbXBvbmVudD47XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgc2Nyb2xsU2VydmljZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLCBkaW1lbnNpb25zU2VydmljZTogTmJMYXlvdXRSdWxlclNlcnZpY2UpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgY2hlY2tQb3NpdGlvbih7IHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgfTogTmJTY3JvbGxhYmxlQ29udGFpbmVyRGltZW50aW9ucyk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBnZXRDb250YWluZXJEaW1lbnNpb25zO1xuICAgIHByaXZhdGUgaW5TeW5jV2l0aERvbTtcbn1cbiJdfQ==