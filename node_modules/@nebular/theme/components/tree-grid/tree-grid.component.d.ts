import { AfterViewInit, ChangeDetectorRef, ElementRef, IterableDiffers, OnDestroy } from '@angular/core';
import { NbPlatform } from '../cdk/platform/platform-service';
import { NbDirectionality } from '../cdk/bidi/bidi-service';
import { NbTable } from '../cdk/table/table.module';
import { NbTreeGridDataSource, NbTreeGridDataSourceBuilder } from './data-source/tree-grid-data-source';
import { NbTreeGridPresentationNode } from './data-source/tree-grid.model';
import { NbToggleOptions } from './data-source/tree-grid.service';
import { NbTreeGridRowComponent } from './tree-grid-row.component';
import { NbTreeGridCellDirective } from './tree-grid-cell.component';
import { NbBooleanInput } from '../helpers';
/**
 * Tree grid component that can be used to display nested rows of data.
 * Supports filtering and sorting.
 * @stacked-example(Showcase, tree-grid/tree-grid-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTreeGridModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTreeGridModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * As the most basic usage you need to define [nbTreeGridRowDef](docs/components/treegrid/api#nbtreegridrowdefdirective)
 * where you should pass columns to display in rows and
 * [nbTreeGridColumnDef](docs/components/treegrid/api#nbtreegridcolumndefdirective) - component containing cell
 * definitions for each column passed to row definition.
 * @stacked-example(Basic, tree-grid/tree-grid-basic.component)
 *
 * `NbTreeGridComponent`'s source input and `NbTreeGridDataSourceBuilder.create` expecting data to be an array of
 * objects with `data`, `children` and `expanded` properties. If your data doesn't match this interface, you can pass
 * getter functions for each property as arguments to `NbTreeGridDataSourceBuilder.create` method.
 * @stacked-example(Custom node structure, tree-grid/tree-grid-custom-node-structure.component)
 *
 * To use sorting you can add `nbSort` directive to table and subscribe to `sort` method. When user click on header,
 * sort event will be emitted. Event object contain clicked column name and desired sort direction.
 * @stacked-example(Sortable, tree-grid/tree-grid-sortable.component)
 *
 * You can use `Data Source Builder` to create `NbTreeGridDataSource` which would have toggle, sort and
 * filter methods. Then you can call this methods to change sort or toggle rows programmatically. Also `nbSort` and
 * `nbFilterInput` directives both support `NbTreeGridDataSource`, so you can pass it directly as an input and
 * directives will trigger sort, toggle themselves.
 * @stacked-example(Data Source Builder, tree-grid/tree-grid-showcase.component)
 *
 * You can create responsive grid by setting `hideOn` and `showOn` inputs of
 * [nbTreeGridColumnDef](docs/components/tree-grid/api#nbtreegridcolumndefdirective) directive.
 * When viewport reaches specified width grid hides or shows columns.
 * @stacked-example(Responsive columns, tree-grid/tree-grid-responsive.component)
 *
 * To customize sort or row toggle icons you can use `nbSortHeaderIcon` and `nbTreeGridRowToggle` directives
 * respectively. `nbSortHeaderIcon` is a structural directive and it's implicit context set to current direction.
 * Also context has three properties: `isAscending`, `isDescending` and `isNone`.
 * @stacked-example(Custom icons, tree-grid/tree-grid-custom-icons.component)
 *
 * By default, row to toggle happens when user clicks anywhere in the row. Also double click expands row deeply.
 * To disable this you can set `[clickToToggle]="false"` input of `nbTreeGridRow`.
 * @stacked-example(Disable click toggle, tree-grid/tree-grid-disable-click-toggle.component)
 *
 * @styles
 *
 * tree-grid-cell-border-width:
 * tree-grid-cell-border-style:
 * tree-grid-cell-border-color:
 * tree-grid-row-min-height:
 * tree-grid-cell-padding:
 * tree-grid-header-background-color:
 * tree-grid-header-text-color:
 * tree-grid-header-text-font-family:
 * tree-grid-header-text-font-size:
 * tree-grid-header-text-font-weight:
 * tree-grid-header-text-line-height:
 * tree-grid-footer-background-color:
 * tree-grid-footer-text-color:
 * tree-grid-footer-text-font-family:
 * tree-grid-footer-text-font-size:
 * tree-grid-footer-text-font-weight:
 * tree-grid-footer-text-line-height:
 * tree-grid-row-background-color:
 * tree-grid-row-even-background-color:
 * tree-grid-row-hover-background-color:
 * tree-grid-row-text-color:
 * tree-grid-row-text-font-family:
 * tree-grid-row-text-font-size:
 * tree-grid-row-text-font-weight:
 * tree-grid-row-text-line-height:
 * tree-grid-sort-header-button-background-color:
 * tree-grid-sort-header-button-border:
 * tree-grid-sort-header-button-padding:
 */
import * as ɵngcc0 from '@angular/core';
export declare class NbTreeGridComponent<T> extends NbTable<NbTreeGridPresentationNode<T>> implements AfterViewInit, OnDestroy {
    private dataSourceBuilder;
    private window;
    constructor(dataSourceBuilder: NbTreeGridDataSourceBuilder<T>, differs: IterableDiffers, changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef, role: string, dir: NbDirectionality, document: any, platform: NbPlatform, window: any);
    private destroy$;
    private _source;
    private platform;
    /**
     * The table's data
     * @param data
     * @type {<T>[] | NbTreeGridDataSource}
     */
    set source(data: T[] | NbTreeGridDataSource<T>);
    levelPadding: string;
    /**
     * Make all columns equal width. False by default.
     */
    set equalColumnsWidth(value: boolean);
    get equalColumnsWidth(): boolean;
    private equalColumnsWidthValue;
    static ngAcceptInputType_equalColumnsWidth: NbBooleanInput;
    readonly treeClass = true;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    toggleRow(row: NbTreeGridRowComponent, options?: NbToggleOptions): void;
    toggleCellRow(cell: NbTreeGridCellDirective): void;
    getColumnWidth(): string;
    getCellLevel(cell: NbTreeGridCellDirective, columnName: string): number;
    private getRowContext;
    private getCellContext;
    private getContextByCellEl;
    private getContextByRowEl;
    private getColumns;
    private getColumnsCount;
    private isFirstColumn;
    private checkDefsCount;
    private updateVisibleColumns;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbTreeGridComponent<any>, [null, null, null, null, { attribute: "role"; }, null, null, null, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbTreeGridComponent<any>, "table[nbTreeGrid]", never, { "levelPadding": "levelPadding"; "source": "nbTreeGrid"; "equalColumnsWidth": "equalColumnsWidth"; }, {}, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJ0cmVlLWdyaWQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBJdGVyYWJsZURpZmZlcnMsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmJQbGF0Zm9ybSB9IGZyb20gJy4uL2Nkay9wbGF0Zm9ybS9wbGF0Zm9ybS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iRGlyZWN0aW9uYWxpdHkgfSBmcm9tICcuLi9jZGsvYmlkaS9iaWRpLXNlcnZpY2UnO1xuaW1wb3J0IHsgTmJUYWJsZSB9IGZyb20gJy4uL2Nkay90YWJsZS90YWJsZS5tb2R1bGUnO1xuaW1wb3J0IHsgTmJUcmVlR3JpZERhdGFTb3VyY2UsIE5iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlciB9IGZyb20gJy4vZGF0YS1zb3VyY2UvdHJlZS1ncmlkLWRhdGEtc291cmNlJztcbmltcG9ydCB7IE5iVHJlZUdyaWRQcmVzZW50YXRpb25Ob2RlIH0gZnJvbSAnLi9kYXRhLXNvdXJjZS90cmVlLWdyaWQubW9kZWwnO1xuaW1wb3J0IHsgTmJUb2dnbGVPcHRpb25zIH0gZnJvbSAnLi9kYXRhLXNvdXJjZS90cmVlLWdyaWQuc2VydmljZSc7XG5pbXBvcnQgeyBOYlRyZWVHcmlkUm93Q29tcG9uZW50IH0gZnJvbSAnLi90cmVlLWdyaWQtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IE5iQm9vbGVhbklucHV0IH0gZnJvbSAnLi4vaGVscGVycyc7XG4vKipcbiAqIFRyZWUgZ3JpZCBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5lc3RlZCByb3dzIG9mIGRhdGEuXG4gKiBTdXBwb3J0cyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRyZWVHcmlkTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRyZWVHcmlkTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogQXMgdGhlIG1vc3QgYmFzaWMgdXNhZ2UgeW91IG5lZWQgdG8gZGVmaW5lIFtuYlRyZWVHcmlkUm93RGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZWdyaWQvYXBpI25idHJlZWdyaWRyb3dkZWZkaXJlY3RpdmUpXG4gKiB3aGVyZSB5b3Ugc2hvdWxkIHBhc3MgY29sdW1ucyB0byBkaXNwbGF5IGluIHJvd3MgYW5kXG4gKiBbbmJUcmVlR3JpZENvbHVtbkRlZl0oZG9jcy9jb21wb25lbnRzL3RyZWVncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSAtIGNvbXBvbmVudCBjb250YWluaW5nIGNlbGxcbiAqIGRlZmluaXRpb25zIGZvciBlYWNoIGNvbHVtbiBwYXNzZWQgdG8gcm93IGRlZmluaXRpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJhc2ljLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWJhc2ljLmNvbXBvbmVudClcbiAqXG4gKiBgTmJUcmVlR3JpZENvbXBvbmVudGAncyBzb3VyY2UgaW5wdXQgYW5kIGBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIuY3JlYXRlYCBleHBlY3RpbmcgZGF0YSB0byBiZSBhbiBhcnJheSBvZlxuICogb2JqZWN0cyB3aXRoIGBkYXRhYCwgYGNoaWxkcmVuYCBhbmQgYGV4cGFuZGVkYCBwcm9wZXJ0aWVzLiBJZiB5b3VyIGRhdGEgZG9lc24ndCBtYXRjaCB0aGlzIGludGVyZmFjZSwgeW91IGNhbiBwYXNzXG4gKiBnZXR0ZXIgZnVuY3Rpb25zIGZvciBlYWNoIHByb3BlcnR5IGFzIGFyZ3VtZW50cyB0byBgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLmNyZWF0ZWAgbWV0aG9kLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gbm9kZSBzdHJ1Y3R1cmUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLW5vZGUtc3RydWN0dXJlLmNvbXBvbmVudClcbiAqXG4gKiBUbyB1c2Ugc29ydGluZyB5b3UgY2FuIGFkZCBgbmJTb3J0YCBkaXJlY3RpdmUgdG8gdGFibGUgYW5kIHN1YnNjcmliZSB0byBgc29ydGAgbWV0aG9kLiBXaGVuIHVzZXIgY2xpY2sgb24gaGVhZGVyLFxuICogc29ydCBldmVudCB3aWxsIGJlIGVtaXR0ZWQuIEV2ZW50IG9iamVjdCBjb250YWluIGNsaWNrZWQgY29sdW1uIG5hbWUgYW5kIGRlc2lyZWQgc29ydCBkaXJlY3Rpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNvcnRhYmxlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNvcnRhYmxlLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIHVzZSBgRGF0YSBTb3VyY2UgQnVpbGRlcmAgdG8gY3JlYXRlIGBOYlRyZWVHcmlkRGF0YVNvdXJjZWAgd2hpY2ggd291bGQgaGF2ZSB0b2dnbGUsIHNvcnQgYW5kXG4gKiBmaWx0ZXIgbWV0aG9kcy4gVGhlbiB5b3UgY2FuIGNhbGwgdGhpcyBtZXRob2RzIHRvIGNoYW5nZSBzb3J0IG9yIHRvZ2dsZSByb3dzIHByb2dyYW1tYXRpY2FsbHkuIEFsc28gYG5iU29ydGAgYW5kXG4gKiBgbmJGaWx0ZXJJbnB1dGAgZGlyZWN0aXZlcyBib3RoIHN1cHBvcnQgYE5iVHJlZUdyaWREYXRhU291cmNlYCwgc28geW91IGNhbiBwYXNzIGl0IGRpcmVjdGx5IGFzIGFuIGlucHV0IGFuZFxuICogZGlyZWN0aXZlcyB3aWxsIHRyaWdnZXIgc29ydCwgdG9nZ2xlIHRoZW1zZWx2ZXMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERhdGEgU291cmNlIEJ1aWxkZXIsIHRyZWUtZ3JpZC90cmVlLWdyaWQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIHJlc3BvbnNpdmUgZ3JpZCBieSBzZXR0aW5nIGBoaWRlT25gIGFuZCBgc2hvd09uYCBpbnB1dHMgb2ZcbiAqIFtuYlRyZWVHcmlkQ29sdW1uRGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZS1ncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSBkaXJlY3RpdmUuXG4gKiBXaGVuIHZpZXdwb3J0IHJlYWNoZXMgc3BlY2lmaWVkIHdpZHRoIGdyaWQgaGlkZXMgb3Igc2hvd3MgY29sdW1ucy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoUmVzcG9uc2l2ZSBjb2x1bW5zLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXJlc3BvbnNpdmUuY29tcG9uZW50KVxuICpcbiAqIFRvIGN1c3RvbWl6ZSBzb3J0IG9yIHJvdyB0b2dnbGUgaWNvbnMgeW91IGNhbiB1c2UgYG5iU29ydEhlYWRlckljb25gIGFuZCBgbmJUcmVlR3JpZFJvd1RvZ2dsZWAgZGlyZWN0aXZlc1xuICogcmVzcGVjdGl2ZWx5LiBgbmJTb3J0SGVhZGVySWNvbmAgaXMgYSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBhbmQgaXQncyBpbXBsaWNpdCBjb250ZXh0IHNldCB0byBjdXJyZW50IGRpcmVjdGlvbi5cbiAqIEFsc28gY29udGV4dCBoYXMgdGhyZWUgcHJvcGVydGllczogYGlzQXNjZW5kaW5nYCwgYGlzRGVzY2VuZGluZ2AgYW5kIGBpc05vbmVgLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gaWNvbnMsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLWljb25zLmNvbXBvbmVudClcbiAqXG4gKiBCeSBkZWZhdWx0LCByb3cgdG8gdG9nZ2xlIGhhcHBlbnMgd2hlbiB1c2VyIGNsaWNrcyBhbnl3aGVyZSBpbiB0aGUgcm93LiBBbHNvIGRvdWJsZSBjbGljayBleHBhbmRzIHJvdyBkZWVwbHkuXG4gKiBUbyBkaXNhYmxlIHRoaXMgeW91IGNhbiBzZXQgYFtjbGlja1RvVG9nZ2xlXT1cImZhbHNlXCJgIGlucHV0IG9mIGBuYlRyZWVHcmlkUm93YC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZSBjbGljayB0b2dnbGUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtZGlzYWJsZS1jbGljay10b2dnbGUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItd2lkdGg6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItc3R5bGU6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LW1pbi1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtY2VsbC1wYWRkaW5nOlxuICogdHJlZS1ncmlkLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1mb290ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LWV2ZW4tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJvcmRlcjpcbiAqIHRyZWUtZ3JpZC1zb3J0LWhlYWRlci1idXR0b24tcGFkZGluZzpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJUcmVlR3JpZENvbXBvbmVudDxUPiBleHRlbmRzIE5iVGFibGU8TmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGU8VD4+IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIGRhdGFTb3VyY2VCdWlsZGVyO1xuICAgIHByaXZhdGUgd2luZG93O1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VCdWlsZGVyOiBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXI8VD4sIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByb2xlOiBzdHJpbmcsIGRpcjogTmJEaXJlY3Rpb25hbGl0eSwgZG9jdW1lbnQ6IGFueSwgcGxhdGZvcm06IE5iUGxhdGZvcm0sIHdpbmRvdzogYW55KTtcbiAgICBwcml2YXRlIGRlc3Ryb3kkO1xuICAgIHByaXZhdGUgX3NvdXJjZTtcbiAgICBwcml2YXRlIHBsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIFRoZSB0YWJsZSdzIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEB0eXBlIHs8VD5bXSB8IE5iVHJlZUdyaWREYXRhU291cmNlfVxuICAgICAqL1xuICAgIHNldCBzb3VyY2UoZGF0YTogVFtdIHwgTmJUcmVlR3JpZERhdGFTb3VyY2U8VD4pO1xuICAgIGxldmVsUGFkZGluZzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ha2UgYWxsIGNvbHVtbnMgZXF1YWwgd2lkdGguIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgc2V0IGVxdWFsQ29sdW1uc1dpZHRoKHZhbHVlOiBib29sZWFuKTtcbiAgICBnZXQgZXF1YWxDb2x1bW5zV2lkdGgoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIGVxdWFsQ29sdW1uc1dpZHRoVmFsdWU7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2VxdWFsQ29sdW1uc1dpZHRoOiBOYkJvb2xlYW5JbnB1dDtcbiAgICByZWFkb25seSB0cmVlQ2xhc3MgPSB0cnVlO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgdG9nZ2xlUm93KHJvdzogTmJUcmVlR3JpZFJvd0NvbXBvbmVudCwgb3B0aW9ucz86IE5iVG9nZ2xlT3B0aW9ucyk6IHZvaWQ7XG4gICAgdG9nZ2xlQ2VsbFJvdyhjZWxsOiBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSk6IHZvaWQ7XG4gICAgZ2V0Q29sdW1uV2lkdGgoKTogc3RyaW5nO1xuICAgIGdldENlbGxMZXZlbChjZWxsOiBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSwgY29sdW1uTmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICAgIHByaXZhdGUgZ2V0Um93Q29udGV4dDtcbiAgICBwcml2YXRlIGdldENlbGxDb250ZXh0O1xuICAgIHByaXZhdGUgZ2V0Q29udGV4dEJ5Q2VsbEVsO1xuICAgIHByaXZhdGUgZ2V0Q29udGV4dEJ5Um93RWw7XG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5zO1xuICAgIHByaXZhdGUgZ2V0Q29sdW1uc0NvdW50O1xuICAgIHByaXZhdGUgaXNGaXJzdENvbHVtbjtcbiAgICBwcml2YXRlIGNoZWNrRGVmc0NvdW50O1xuICAgIHByaXZhdGUgdXBkYXRlVmlzaWJsZUNvbHVtbnM7XG59XG4iXX0=