import { EventEmitter, TemplateRef } from '@angular/core';
import { NbBooleanInput, NbNullableInput } from '../helpers';
/** Column definition associated with a `NbSortHeaderDirective`. */
import * as ɵngcc0 from '@angular/core';
interface NbSortHeaderColumnDef {
    name: string;
}
export interface NbSortRequest {
    column: string;
    direction: NbSortDirection;
}
export interface NbSortable {
    sort(sortRequest: NbSortRequest): any;
}
export declare type NbSortDirectionValues = 'asc' | 'desc' | '';
export declare enum NbSortDirection {
    ASCENDING = "asc",
    DESCENDING = "desc",
    NONE = ""
}
/**
 * Directive triggers sort method of passed object when sort header changes direction
 */
export declare class NbSortDirective {
    sortable: NbSortable;
    static ngAcceptInputType_sortable: NbSortable | NbNullableInput;
    sort: EventEmitter<NbSortRequest>;
    emitSort(sortRequest: NbSortRequest): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSortDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbSortDirective, "[nbSort]", never, { "sortable": "nbSort"; }, { "sort": "sort"; }, never>;
}
export interface NbSortHeaderIconDirectiveContext {
    $implicit: NbSortDirection;
    isAscending: boolean;
    isDescending: boolean;
    isNone: boolean;
}
/**
 * Directive for headers sort icons. Mark you icon implementation with this structural directive and
 * it'll set template's implicit context with current direction. Context also has `isAscending`,
 * `isDescending` and `isNone` properties.
 */
export declare class NbSortHeaderIconDirective {
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSortHeaderIconDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbSortHeaderIconDirective, "[nbSortHeaderIcon]", never, {}, {}, never>;
}
export declare class NbSortIconComponent {
    direction: NbSortDirection;
    isAscending(): boolean;
    isDescending(): boolean;
    isDirectionSet(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSortIconComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbSortIconComponent, "nb-sort-icon", never, { "direction": "direction"; }, {}, never, never>;
}
/**
 * Marks header as sort header so it emitting sort event when clicked.
 */
export declare class NbSortHeaderComponent {
    private sort;
    private columnDef;
    sortIcon: TemplateRef<NbSortHeaderIconDirectiveContext>;
    /**
     * Current sort direction. Possible values: `asc`, `desc`, ``(none)
     * @type {NbSortDirection}
     */
    direction: NbSortDirection;
    static ngAcceptInputType_direction: NbSortDirectionValues;
    private disabledValue;
    /**
     * Disable sort header
     */
    set disabled(value: boolean);
    get disabled(): boolean;
    static ngAcceptInputType_disabled: NbBooleanInput;
    sortIfEnabled(): void;
    constructor(sort: NbSortDirective, columnDef: NbSortHeaderColumnDef);
    isAscending(): boolean;
    isDescending(): boolean;
    sortData(): void;
    getIconContext(): NbSortHeaderIconDirectiveContext;
    getDisabledAttributeValue(): '' | null;
    private createSortRequest;
    private getNextDirection;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSortHeaderComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbSortHeaderComponent, "[nbSortHeader]", never, { "disabled": "disabled"; "direction": "nbSortHeader"; }, {}, ["sortIcon"], ["*"]>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLXNvcnQuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInRyZWUtZ3JpZC1zb3J0LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5iQm9vbGVhbklucHV0LCBOYk51bGxhYmxlSW5wdXQgfSBmcm9tICcuLi9oZWxwZXJzJztcbi8qKiBDb2x1bW4gZGVmaW5pdGlvbiBhc3NvY2lhdGVkIHdpdGggYSBgTmJTb3J0SGVhZGVyRGlyZWN0aXZlYC4gKi9cbmludGVyZmFjZSBOYlNvcnRIZWFkZXJDb2x1bW5EZWYge1xuICAgIG5hbWU6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTmJTb3J0UmVxdWVzdCB7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgZGlyZWN0aW9uOiBOYlNvcnREaXJlY3Rpb247XG59XG5leHBvcnQgaW50ZXJmYWNlIE5iU29ydGFibGUge1xuICAgIHNvcnQoc29ydFJlcXVlc3Q6IE5iU29ydFJlcXVlc3QpOiBhbnk7XG59XG5leHBvcnQgZGVjbGFyZSB0eXBlIE5iU29ydERpcmVjdGlvblZhbHVlcyA9ICdhc2MnIHwgJ2Rlc2MnIHwgJyc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIE5iU29ydERpcmVjdGlvbiB7XG4gICAgQVNDRU5ESU5HID0gXCJhc2NcIixcbiAgICBERVNDRU5ESU5HID0gXCJkZXNjXCIsXG4gICAgTk9ORSA9IFwiXCJcbn1cbi8qKlxuICogRGlyZWN0aXZlIHRyaWdnZXJzIHNvcnQgbWV0aG9kIG9mIHBhc3NlZCBvYmplY3Qgd2hlbiBzb3J0IGhlYWRlciBjaGFuZ2VzIGRpcmVjdGlvblxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlNvcnREaXJlY3RpdmUge1xuICAgIHNvcnRhYmxlOiBOYlNvcnRhYmxlO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zb3J0YWJsZTogTmJTb3J0YWJsZSB8IE5iTnVsbGFibGVJbnB1dDtcbiAgICBzb3J0OiBFdmVudEVtaXR0ZXI8TmJTb3J0UmVxdWVzdD47XG4gICAgZW1pdFNvcnQoc29ydFJlcXVlc3Q6IE5iU29ydFJlcXVlc3QpOiB2b2lkO1xufVxuZXhwb3J0IGludGVyZmFjZSBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlQ29udGV4dCB7XG4gICAgJGltcGxpY2l0OiBOYlNvcnREaXJlY3Rpb247XG4gICAgaXNBc2NlbmRpbmc6IGJvb2xlYW47XG4gICAgaXNEZXNjZW5kaW5nOiBib29sZWFuO1xuICAgIGlzTm9uZTogYm9vbGVhbjtcbn1cbi8qKlxuICogRGlyZWN0aXZlIGZvciBoZWFkZXJzIHNvcnQgaWNvbnMuIE1hcmsgeW91IGljb24gaW1wbGVtZW50YXRpb24gd2l0aCB0aGlzIHN0cnVjdHVyYWwgZGlyZWN0aXZlIGFuZFxuICogaXQnbGwgc2V0IHRlbXBsYXRlJ3MgaW1wbGljaXQgY29udGV4dCB3aXRoIGN1cnJlbnQgZGlyZWN0aW9uLiBDb250ZXh0IGFsc28gaGFzIGBpc0FzY2VuZGluZ2AsXG4gKiBgaXNEZXNjZW5kaW5nYCBhbmQgYGlzTm9uZWAgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJTb3J0SGVhZGVySWNvbkRpcmVjdGl2ZSB7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlNvcnRJY29uQ29tcG9uZW50IHtcbiAgICBkaXJlY3Rpb246IE5iU29ydERpcmVjdGlvbjtcbiAgICBpc0FzY2VuZGluZygpOiBib29sZWFuO1xuICAgIGlzRGVzY2VuZGluZygpOiBib29sZWFuO1xuICAgIGlzRGlyZWN0aW9uU2V0KCk6IGJvb2xlYW47XG59XG4vKipcbiAqIE1hcmtzIGhlYWRlciBhcyBzb3J0IGhlYWRlciBzbyBpdCBlbWl0dGluZyBzb3J0IGV2ZW50IHdoZW4gY2xpY2tlZC5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJTb3J0SGVhZGVyQ29tcG9uZW50IHtcbiAgICBwcml2YXRlIHNvcnQ7XG4gICAgcHJpdmF0ZSBjb2x1bW5EZWY7XG4gICAgc29ydEljb246IFRlbXBsYXRlUmVmPE5iU29ydEhlYWRlckljb25EaXJlY3RpdmVDb250ZXh0PjtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHNvcnQgZGlyZWN0aW9uLiBQb3NzaWJsZSB2YWx1ZXM6IGBhc2NgLCBgZGVzY2AsIGBgKG5vbmUpXG4gICAgICogQHR5cGUge05iU29ydERpcmVjdGlvbn1cbiAgICAgKi9cbiAgICBkaXJlY3Rpb246IE5iU29ydERpcmVjdGlvbjtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZGlyZWN0aW9uOiBOYlNvcnREaXJlY3Rpb25WYWx1ZXM7XG4gICAgcHJpdmF0ZSBkaXNhYmxlZFZhbHVlO1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgc29ydCBoZWFkZXJcbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pO1xuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9kaXNhYmxlZDogTmJCb29sZWFuSW5wdXQ7XG4gICAgc29ydElmRW5hYmxlZCgpOiB2b2lkO1xuICAgIGNvbnN0cnVjdG9yKHNvcnQ6IE5iU29ydERpcmVjdGl2ZSwgY29sdW1uRGVmOiBOYlNvcnRIZWFkZXJDb2x1bW5EZWYpO1xuICAgIGlzQXNjZW5kaW5nKCk6IGJvb2xlYW47XG4gICAgaXNEZXNjZW5kaW5nKCk6IGJvb2xlYW47XG4gICAgc29ydERhdGEoKTogdm9pZDtcbiAgICBnZXRJY29uQ29udGV4dCgpOiBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlQ29udGV4dDtcbiAgICBnZXREaXNhYmxlZEF0dHJpYnV0ZVZhbHVlKCk6ICcnIHwgbnVsbDtcbiAgICBwcml2YXRlIGNyZWF0ZVNvcnRSZXF1ZXN0O1xuICAgIHByaXZhdGUgZ2V0TmV4dERpcmVjdGlvbjtcbn1cbmV4cG9ydCB7fTtcbiJdfQ==