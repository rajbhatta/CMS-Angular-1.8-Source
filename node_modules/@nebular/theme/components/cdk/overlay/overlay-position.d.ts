import { ElementRef } from '@angular/core';
import { Observable } from 'rxjs';
import { NbConnectedPosition, NbFlexibleConnectedPositionStrategy, NbOverlayPositionBuilder, NbOverlayRef, NbPositionStrategy } from './mapping';
import { NbPlatform } from '../platform/platform-service';
import { NbOverlayContainerAdapter } from '../adapter/overlay-container-adapter';
import { NbViewportRulerAdapter } from '../adapter/viewport-ruler-adapter';
import { NbGlobalLogicalPosition } from './position-helper';
import { GlobalPositionStrategy } from '@angular/cdk/overlay';
import * as ɵngcc0 from '@angular/core';
export declare enum NbAdjustment {
    NOOP = "noop",
    CLOCKWISE = "clockwise",
    COUNTERCLOCKWISE = "counterclockwise",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal"
}
export declare type NbPositionValues = 'top' | 'bottom' | 'left' | 'right' | 'start' | 'end' | 'top-end' | 'top-start' | 'bottom-end' | 'bottom-start' | 'end-top' | 'end-bottom' | 'start-top' | 'start-bottom';
export declare enum NbPosition {
    TOP = "top",
    BOTTOM = "bottom",
    LEFT = "left",
    RIGHT = "right",
    START = "start",
    END = "end",
    TOP_END = "top-end",
    TOP_START = "top-start",
    BOTTOM_END = "bottom-end",
    BOTTOM_START = "bottom-start",
    END_TOP = "end-top",
    END_BOTTOM = "end-bottom",
    START_TOP = "start-top",
    START_BOTTOM = "start-bottom"
}
/**
 * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.
 * You have to provide adjustment and appropriate strategy will be chosen in runtime.
 * */
export declare class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy implements NbPositionStrategy {
    protected _position: NbPosition;
    protected _offset: number;
    protected _adjustment: NbAdjustment;
    protected appliedPositions: {
        key: NbPosition;
        connectedPosition: NbConnectedPosition;
    }[];
    readonly positionChange: Observable<NbPosition>;
    attach(overlayRef: NbOverlayRef): void;
    apply(): void;
    position(position: NbPosition): this;
    adjustment(adjustment: NbAdjustment): this;
    offset(offset: number): this;
    protected applyPositions(): void;
    protected createPositions(): NbPosition[];
    protected persistChosenPositions(positions: NbPosition[]): void;
    protected reorderPreferredPositions(positions: NbPosition[]): NbPosition[];
    protected mapToLogicalPosition(position: NbPosition): NbPosition;
}
export declare class NbGlobalPositionStrategy extends GlobalPositionStrategy {
    position(position: NbGlobalLogicalPosition): this;
}
export declare class NbPositionBuilderService {
    protected document: any;
    protected viewportRuler: NbViewportRulerAdapter;
    protected platform: NbPlatform;
    protected positionBuilder: NbOverlayPositionBuilder;
    protected overlayContainer: NbOverlayContainerAdapter;
    constructor(document: any, viewportRuler: NbViewportRulerAdapter, platform: NbPlatform, positionBuilder: NbOverlayPositionBuilder, overlayContainer: NbOverlayContainerAdapter);
    global(): NbGlobalPositionStrategy;
    connectedTo(elementRef: ElementRef): NbAdjustableConnectedPositionStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbPositionBuilderService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NbPositionBuilderService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1wb3NpdGlvbi5kLnRzIiwic291cmNlcyI6WyJvdmVybGF5LXBvc2l0aW9uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmJDb25uZWN0ZWRQb3NpdGlvbiwgTmJGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgTmJPdmVybGF5UmVmLCBOYlBvc2l0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL21hcHBpbmcnO1xuaW1wb3J0IHsgTmJQbGF0Zm9ybSB9IGZyb20gJy4uL3BsYXRmb3JtL3BsYXRmb3JtLXNlcnZpY2UnO1xuaW1wb3J0IHsgTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlciB9IGZyb20gJy4uL2FkYXB0ZXIvb3ZlcmxheS1jb250YWluZXItYWRhcHRlcic7XG5pbXBvcnQgeyBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyIH0gZnJvbSAnLi4vYWRhcHRlci92aWV3cG9ydC1ydWxlci1hZGFwdGVyJztcbmltcG9ydCB7IE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbi1oZWxwZXInO1xuaW1wb3J0IHsgR2xvYmFsUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmV4cG9ydCBkZWNsYXJlIGVudW0gTmJBZGp1c3RtZW50IHtcbiAgICBOT09QID0gXCJub29wXCIsXG4gICAgQ0xPQ0tXSVNFID0gXCJjbG9ja3dpc2VcIixcbiAgICBDT1VOVEVSQ0xPQ0tXSVNFID0gXCJjb3VudGVyY2xvY2t3aXNlXCIsXG4gICAgVkVSVElDQUwgPSBcInZlcnRpY2FsXCIsXG4gICAgSE9SSVpPTlRBTCA9IFwiaG9yaXpvbnRhbFwiXG59XG5leHBvcnQgZGVjbGFyZSB0eXBlIE5iUG9zaXRpb25WYWx1ZXMgPSAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdzdGFydCcgfCAnZW5kJyB8ICd0b3AtZW5kJyB8ICd0b3Atc3RhcnQnIHwgJ2JvdHRvbS1lbmQnIHwgJ2JvdHRvbS1zdGFydCcgfCAnZW5kLXRvcCcgfCAnZW5kLWJvdHRvbScgfCAnc3RhcnQtdG9wJyB8ICdzdGFydC1ib3R0b20nO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBOYlBvc2l0aW9uIHtcbiAgICBUT1AgPSBcInRvcFwiLFxuICAgIEJPVFRPTSA9IFwiYm90dG9tXCIsXG4gICAgTEVGVCA9IFwibGVmdFwiLFxuICAgIFJJR0hUID0gXCJyaWdodFwiLFxuICAgIFNUQVJUID0gXCJzdGFydFwiLFxuICAgIEVORCA9IFwiZW5kXCIsXG4gICAgVE9QX0VORCA9IFwidG9wLWVuZFwiLFxuICAgIFRPUF9TVEFSVCA9IFwidG9wLXN0YXJ0XCIsXG4gICAgQk9UVE9NX0VORCA9IFwiYm90dG9tLWVuZFwiLFxuICAgIEJPVFRPTV9TVEFSVCA9IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgRU5EX1RPUCA9IFwiZW5kLXRvcFwiLFxuICAgIEVORF9CT1RUT00gPSBcImVuZC1ib3R0b21cIixcbiAgICBTVEFSVF9UT1AgPSBcInN0YXJ0LXRvcFwiLFxuICAgIFNUQVJUX0JPVFRPTSA9IFwic3RhcnQtYm90dG9tXCJcbn1cbi8qKlxuICogVGhlIG1haW4gaWRlYSBvZiB0aGUgYWRqdXN0YWJsZSBjb25uZWN0ZWQgc3RyYXRlZ3kgaXMgdG8gcHJvdmlkZSBwcmVkZWZpbmVkIHNldCBvZiBwb3NpdGlvbnMgZm9yIHlvdXIgb3ZlcmxheS5cbiAqIFlvdSBoYXZlIHRvIHByb3ZpZGUgYWRqdXN0bWVudCBhbmQgYXBwcm9wcmlhdGUgc3RyYXRlZ3kgd2lsbCBiZSBjaG9zZW4gaW4gcnVudGltZS5cbiAqICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgTmJGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgaW1wbGVtZW50cyBOYlBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHByb3RlY3RlZCBfcG9zaXRpb246IE5iUG9zaXRpb247XG4gICAgcHJvdGVjdGVkIF9vZmZzZXQ6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2FkanVzdG1lbnQ6IE5iQWRqdXN0bWVudDtcbiAgICBwcm90ZWN0ZWQgYXBwbGllZFBvc2l0aW9uczoge1xuICAgICAgICBrZXk6IE5iUG9zaXRpb247XG4gICAgICAgIGNvbm5lY3RlZFBvc2l0aW9uOiBOYkNvbm5lY3RlZFBvc2l0aW9uO1xuICAgIH1bXTtcbiAgICByZWFkb25seSBwb3NpdGlvbkNoYW5nZTogT2JzZXJ2YWJsZTxOYlBvc2l0aW9uPjtcbiAgICBhdHRhY2gob3ZlcmxheVJlZjogTmJPdmVybGF5UmVmKTogdm9pZDtcbiAgICBhcHBseSgpOiB2b2lkO1xuICAgIHBvc2l0aW9uKHBvc2l0aW9uOiBOYlBvc2l0aW9uKTogdGhpcztcbiAgICBhZGp1c3RtZW50KGFkanVzdG1lbnQ6IE5iQWRqdXN0bWVudCk6IHRoaXM7XG4gICAgb2Zmc2V0KG9mZnNldDogbnVtYmVyKTogdGhpcztcbiAgICBwcm90ZWN0ZWQgYXBwbHlQb3NpdGlvbnMoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgY3JlYXRlUG9zaXRpb25zKCk6IE5iUG9zaXRpb25bXTtcbiAgICBwcm90ZWN0ZWQgcGVyc2lzdENob3NlblBvc2l0aW9ucyhwb3NpdGlvbnM6IE5iUG9zaXRpb25bXSk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHJlb3JkZXJQcmVmZXJyZWRQb3NpdGlvbnMocG9zaXRpb25zOiBOYlBvc2l0aW9uW10pOiBOYlBvc2l0aW9uW107XG4gICAgcHJvdGVjdGVkIG1hcFRvTG9naWNhbFBvc2l0aW9uKHBvc2l0aW9uOiBOYlBvc2l0aW9uKTogTmJQb3NpdGlvbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHBvc2l0aW9uKHBvc2l0aW9uOiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbik6IHRoaXM7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2Uge1xuICAgIHByb3RlY3RlZCBkb2N1bWVudDogYW55O1xuICAgIHByb3RlY3RlZCB2aWV3cG9ydFJ1bGVyOiBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyO1xuICAgIHByb3RlY3RlZCBwbGF0Zm9ybTogTmJQbGF0Zm9ybTtcbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25CdWlsZGVyOiBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXI7XG4gICAgcHJvdGVjdGVkIG92ZXJsYXlDb250YWluZXI6IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXI7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQ6IGFueSwgdmlld3BvcnRSdWxlcjogTmJWaWV3cG9ydFJ1bGVyQWRhcHRlciwgcGxhdGZvcm06IE5iUGxhdGZvcm0sIHBvc2l0aW9uQnVpbGRlcjogTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyLCBvdmVybGF5Q29udGFpbmVyOiBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyKTtcbiAgICBnbG9iYWwoKTogTmJHbG9iYWxQb3NpdGlvblN0cmF0ZWd5O1xuICAgIGNvbm5lY3RlZFRvKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpOiBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xufVxuIl19