/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { OnInit, OnDestroy, ElementRef, OnChanges } from '@angular/core';
import { Subscription } from 'rxjs';
import { NbBooleanInput } from '../helpers';
import { NbThemeService } from '../../services/theme.service';
import { NbSidebarService } from './sidebar.service';
/**
 * Sidebar header container.
 *
 * Placeholder which contains a sidebar header content,
 * placed at the very top of the sidebar outside of the scroll area.
 */
import * as ɵngcc0 from '@angular/core';
export declare class NbSidebarHeaderComponent {
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSidebarHeaderComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbSidebarHeaderComponent, "nb-sidebar-header", never, {}, {}, never, ["*"]>;
}
/**
 * Sidebar footer container.
 *
 * Placeholder which contains a sidebar footer content,
 * placed at the very bottom of the sidebar outside of the scroll area.
 */
export declare class NbSidebarFooterComponent {
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSidebarFooterComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbSidebarFooterComponent, "nb-sidebar-footer", never, {}, {}, never, ["*"]>;
}
/**
 * Layout sidebar component.
 *
 * @stacked-example(Showcase, sidebar/sidebar-showcase.component)
 *
 * ### Installation
 *
 * Import `NbSidebarModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * and `NbSidebarModule` to your feature module where the component should be shown:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Sidebar can be placed on the left or the right side of the layout,
 * or on start/end position of layout (depends on document direction, left to right or right to left)
 * It can be fixed (shown above the content) or can push the layout when opened.
 *
 * There are three states - `expanded`, `collapsed`, `compacted`.
 * By default sidebar content is fixed and saves its position while the page is being scrolled.
 *
 * Compacted sidebar example:
 * @stacked-example(Compacted Sidebar, sidebar/sidebar-compacted.component)
 *
 * Sidebar also supports a `responsive` behavior, listening to window size change and changing its size respectably.
 *
 * In a pair with header it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * @additional-example(Right Sidebar, sidebar/sidebar-right.component)
 * @additional-example(Fixed Sidebar, sidebar/sidebar-fixed.component)
 *
 * @styles
 *
 * sidebar-background-color:
 * sidebar-text-color:
 * sidebar-text-font-family:
 * sidebar-text-font-size:
 * sidebar-text-font-weight:
 * sidebar-text-line-height:
 * sidebar-height:
 * sidebar-width:
 * sidebar-width-compact:
 * sidebar-padding:
 * sidebar-header-height:
 * sidebar-footer-height:
 * sidebar-shadow:
 * sidebar-menu-item-highlight-color:
 * sidebar-scrollbar-background-color:
 * sidebar-scrollbar-color:
 * sidebar-scrollbar-width:
 */
export declare class NbSidebarComponent implements OnChanges, OnInit, OnDestroy {
    private sidebarService;
    private themeService;
    private element;
    static readonly STATE_EXPANDED: string;
    static readonly STATE_COLLAPSED: string;
    static readonly STATE_COMPACTED: string;
    static readonly RESPONSIVE_STATE_MOBILE: string;
    static readonly RESPONSIVE_STATE_TABLET: string;
    static readonly RESPONSIVE_STATE_PC: string;
    protected stateValue: string;
    protected responsiveValue: boolean;
    private destroy$;
    containerFixedValue: boolean;
    fixedValue: boolean;
    rightValue: boolean;
    leftValue: boolean;
    startValue: boolean;
    endValue: boolean;
    get expanded(): boolean;
    get collapsed(): boolean;
    get compacted(): boolean;
    /**
     * Places sidebar on the right side
     * @type {boolean}
     */
    set right(val: boolean);
    static ngAcceptInputType_right: NbBooleanInput;
    /**
     * Places sidebar on the left side
     * @type {boolean}
     */
    set left(val: boolean);
    static ngAcceptInputType_left: NbBooleanInput;
    /**
     * Places sidebar on the start edge of layout
     * @type {boolean}
     */
    set start(val: boolean);
    static ngAcceptInputType_start: NbBooleanInput;
    /**
     * Places sidebar on the end edge of layout
     * @type {boolean}
     */
    set end(val: boolean);
    static ngAcceptInputType_end: NbBooleanInput;
    /**
     * Makes sidebar fixed (shown above the layout content)
     * @type {boolean}
     */
    set fixed(val: boolean);
    static ngAcceptInputType_fixed: NbBooleanInput;
    /**
     * Makes sidebar container fixed
     * @type {boolean}
     */
    set containerFixed(val: boolean);
    static ngAcceptInputType_containerFixed: NbBooleanInput;
    /**
     * Initial sidebar state, `expanded`|`collapsed`|`compacted`
     * @type {string}
     */
    set state(val: string);
    /**
     * Makes sidebar listen to media query events and change its behaviour
     * @type {boolean}
     */
    set responsive(val: boolean);
    static ngAcceptInputType_responsive: NbBooleanInput;
    /**
     * Tags a sidebar with some ID, can be later used in the sidebar service
     * to determine which sidebar triggered the action, if multiple sidebars exist on the page.
     *
     * @type {string}
     */
    tag: string;
    /**
     * Controls on which screen sizes sidebar should be switched to compacted state.
     * Works only when responsive mode is on.
     * Default values are `['xs', 'is', 'sm', 'md', 'lg']`.
     *
     * @type string[]
     */
    compactedBreakpoints: string[];
    /**
     * Controls on which screen sizes sidebar should be switched to collapsed state.
     * Works only when responsive mode is on.
     * Default values are `['xs', 'is']`.
     *
     * @type string[]
     */
    collapsedBreakpoints: string[];
    private mediaQuerySubscription;
    private responsiveState;
    constructor(sidebarService: NbSidebarService, themeService: NbThemeService, element: ElementRef);
    toggleResponsive(enabled: boolean): void;
    ngOnChanges(changes: any): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    onClick(event: any): void;
    /**
     * Collapses the sidebar
     */
    collapse(): void;
    /**
     * Expands the sidebar
     */
    expand(): void;
    /**
     * Compacts the sidebar (minimizes)
     */
    compact(): void;
    /**
     * Toggles sidebar state (expanded|collapsed|compacted)
     * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
     * otherwise - between expanded & collapsed. False by default.
     *
     * Toggle sidebar state
     *
     * ```ts
     * this.sidebar.toggle(true);
     * ```
     */
    toggle(compact?: boolean): void;
    protected onMediaQueryChanges(): Subscription;
    protected responsiveEnabled(): boolean;
    protected getMenuLink(element: HTMLElement): HTMLElement | undefined;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbSidebarComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbSidebarComponent, "nb-sidebar", never, { "compactedBreakpoints": "compactedBreakpoints"; "collapsedBreakpoints": "collapsedBreakpoints"; "right": "right"; "left": "left"; "start": "start"; "end": "end"; "fixed": "fixed"; "containerFixed": "containerFixed"; "state": "state"; "responsive": "responsive"; "tag": "tag"; }, {}, never, ["nb-sidebar-header", "*", "nb-sidebar-footer"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lkZWJhci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsic2lkZWJhci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5pbXBvcnQgeyBPbkluaXQsIE9uRGVzdHJveSwgRWxlbWVudFJlZiwgT25DaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5iQm9vbGVhbklucHV0IH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBOYlRoZW1lU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RoZW1lLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJTaWRlYmFyU2VydmljZSB9IGZyb20gJy4vc2lkZWJhci5zZXJ2aWNlJztcbi8qKlxuICogU2lkZWJhciBoZWFkZXIgY29udGFpbmVyLlxuICpcbiAqIFBsYWNlaG9sZGVyIHdoaWNoIGNvbnRhaW5zIGEgc2lkZWJhciBoZWFkZXIgY29udGVudCxcbiAqIHBsYWNlZCBhdCB0aGUgdmVyeSB0b3Agb2YgdGhlIHNpZGViYXIgb3V0c2lkZSBvZiB0aGUgc2Nyb2xsIGFyZWEuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iU2lkZWJhckhlYWRlckNvbXBvbmVudCB7XG59XG4vKipcbiAqIFNpZGViYXIgZm9vdGVyIGNvbnRhaW5lci5cbiAqXG4gKiBQbGFjZWhvbGRlciB3aGljaCBjb250YWlucyBhIHNpZGViYXIgZm9vdGVyIGNvbnRlbnQsXG4gKiBwbGFjZWQgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBzaWRlYmFyIG91dHNpZGUgb2YgdGhlIHNjcm9sbCBhcmVhLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlNpZGViYXJGb290ZXJDb21wb25lbnQge1xufVxuLyoqXG4gKiBMYXlvdXQgc2lkZWJhciBjb21wb25lbnQuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgc2lkZWJhci9zaWRlYmFyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlNpZGViYXJNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIGFwcCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iU2lkZWJhck1vZHVsZS5mb3JSb290KCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICogYW5kIGBOYlNpZGViYXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUgd2hlcmUgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgc2hvd246XG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iU2lkZWJhck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogU2lkZWJhciBjYW4gYmUgcGxhY2VkIG9uIHRoZSBsZWZ0IG9yIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXlvdXQsXG4gKiBvciBvbiBzdGFydC9lbmQgcG9zaXRpb24gb2YgbGF5b3V0IChkZXBlbmRzIG9uIGRvY3VtZW50IGRpcmVjdGlvbiwgbGVmdCB0byByaWdodCBvciByaWdodCB0byBsZWZ0KVxuICogSXQgY2FuIGJlIGZpeGVkIChzaG93biBhYm92ZSB0aGUgY29udGVudCkgb3IgY2FuIHB1c2ggdGhlIGxheW91dCB3aGVuIG9wZW5lZC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgc3RhdGVzIC0gYGV4cGFuZGVkYCwgYGNvbGxhcHNlZGAsIGBjb21wYWN0ZWRgLlxuICogQnkgZGVmYXVsdCBzaWRlYmFyIGNvbnRlbnQgaXMgZml4ZWQgYW5kIHNhdmVzIGl0cyBwb3NpdGlvbiB3aGlsZSB0aGUgcGFnZSBpcyBiZWluZyBzY3JvbGxlZC5cbiAqXG4gKiBDb21wYWN0ZWQgc2lkZWJhciBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShDb21wYWN0ZWQgU2lkZWJhciwgc2lkZWJhci9zaWRlYmFyLWNvbXBhY3RlZC5jb21wb25lbnQpXG4gKlxuICogU2lkZWJhciBhbHNvIHN1cHBvcnRzIGEgYHJlc3BvbnNpdmVgIGJlaGF2aW9yLCBsaXN0ZW5pbmcgdG8gd2luZG93IHNpemUgY2hhbmdlIGFuZCBjaGFuZ2luZyBpdHMgc2l6ZSByZXNwZWN0YWJseS5cbiAqXG4gKiBJbiBhIHBhaXIgd2l0aCBoZWFkZXIgaXQgaXMgcG9zc2libGUgdG8gc2V0dXAgYSBjb25maWd1cmF0aW9uIHdoZW4gaGVhZGVyIGlzIHBsYWNlZCBvbiBhIHNpZGUgb2YgdGhlIHNpZGViYXJcbiAqIGFuZCBub3Qgb24gdG9wIG9mIGl0LiBUbyBhY2hpZXZlIHRoaXMgc2ltcGx5IHB1dCBhIGBzdWJoZWFkZXJgIHByb3BlcnR5IHRvIHRoZSBoZWFkZXIgbGlrZSB0aGlzOlxuICogYGBgaHRtbFxuICogPG5iLWxheW91dC1oZWFkZXIgc3ViaGVhZGVyPjwvbmItbGF5b3V0LWhlYWRlcj5cbiAqIGBgYFxuICogQHN0YWNrZWQtZXhhbXBsZShTdWJoZWFkZXIsIGxheW91dC9sYXlvdXQtc2lkZWJhci1zdWJoZWFkZXIuY29tcG9uZW50KVxuICogTm90ZSB0aGF0IGluIHN1Y2ggY29uZmlndXJhdGlvbiBzaWRlYmFyIHNoYWRvdyBpcyByZW1vdmVkIGFuZCBoZWFkZXIgY2Fubm90IGJlIG1ha2UgYGZpeGVkYC5cbiAqXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKFJpZ2h0IFNpZGViYXIsIHNpZGViYXIvc2lkZWJhci1yaWdodC5jb21wb25lbnQpXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKEZpeGVkIFNpZGViYXIsIHNpZGViYXIvc2lkZWJhci1maXhlZC5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHNpZGViYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNpZGViYXItdGV4dC1jb2xvcjpcbiAqIHNpZGViYXItdGV4dC1mb250LWZhbWlseTpcbiAqIHNpZGViYXItdGV4dC1mb250LXNpemU6XG4gKiBzaWRlYmFyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzaWRlYmFyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzaWRlYmFyLWhlaWdodDpcbiAqIHNpZGViYXItd2lkdGg6XG4gKiBzaWRlYmFyLXdpZHRoLWNvbXBhY3Q6XG4gKiBzaWRlYmFyLXBhZGRpbmc6XG4gKiBzaWRlYmFyLWhlYWRlci1oZWlnaHQ6XG4gKiBzaWRlYmFyLWZvb3Rlci1oZWlnaHQ6XG4gKiBzaWRlYmFyLXNoYWRvdzpcbiAqIHNpZGViYXItbWVudS1pdGVtLWhpZ2hsaWdodC1jb2xvcjpcbiAqIHNpZGViYXItc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzaWRlYmFyLXNjcm9sbGJhci1jb2xvcjpcbiAqIHNpZGViYXItc2Nyb2xsYmFyLXdpZHRoOlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYlNpZGViYXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHNpZGViYXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgdGhlbWVTZXJ2aWNlO1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBzdGF0aWMgcmVhZG9ubHkgU1RBVEVfRVhQQU5ERUQ6IHN0cmluZztcbiAgICBzdGF0aWMgcmVhZG9ubHkgU1RBVEVfQ09MTEFQU0VEOiBzdHJpbmc7XG4gICAgc3RhdGljIHJlYWRvbmx5IFNUQVRFX0NPTVBBQ1RFRDogc3RyaW5nO1xuICAgIHN0YXRpYyByZWFkb25seSBSRVNQT05TSVZFX1NUQVRFX01PQklMRTogc3RyaW5nO1xuICAgIHN0YXRpYyByZWFkb25seSBSRVNQT05TSVZFX1NUQVRFX1RBQkxFVDogc3RyaW5nO1xuICAgIHN0YXRpYyByZWFkb25seSBSRVNQT05TSVZFX1NUQVRFX1BDOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHN0YXRlVmFsdWU6IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgcmVzcG9uc2l2ZVZhbHVlOiBib29sZWFuO1xuICAgIHByaXZhdGUgZGVzdHJveSQ7XG4gICAgY29udGFpbmVyRml4ZWRWYWx1ZTogYm9vbGVhbjtcbiAgICBmaXhlZFZhbHVlOiBib29sZWFuO1xuICAgIHJpZ2h0VmFsdWU6IGJvb2xlYW47XG4gICAgbGVmdFZhbHVlOiBib29sZWFuO1xuICAgIHN0YXJ0VmFsdWU6IGJvb2xlYW47XG4gICAgZW5kVmFsdWU6IGJvb2xlYW47XG4gICAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW47XG4gICAgZ2V0IGNvbGxhcHNlZCgpOiBib29sZWFuO1xuICAgIGdldCBjb21wYWN0ZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQbGFjZXMgc2lkZWJhciBvbiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCByaWdodCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yaWdodDogTmJCb29sZWFuSW5wdXQ7XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHNpZGViYXIgb24gdGhlIGxlZnQgc2lkZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBsZWZ0KHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2xlZnQ6IE5iQm9vbGVhbklucHV0O1xuICAgIC8qKlxuICAgICAqIFBsYWNlcyBzaWRlYmFyIG9uIHRoZSBzdGFydCBlZGdlIG9mIGxheW91dFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBzdGFydCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdGFydDogTmJCb29sZWFuSW5wdXQ7XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHNpZGViYXIgb24gdGhlIGVuZCBlZGdlIG9mIGxheW91dFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBlbmQodmFsOiBib29sZWFuKTtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5kOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBzaWRlYmFyIGZpeGVkIChzaG93biBhYm92ZSB0aGUgbGF5b3V0IGNvbnRlbnQpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGZpeGVkKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2ZpeGVkOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBzaWRlYmFyIGNvbnRhaW5lciBmaXhlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBjb250YWluZXJGaXhlZCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb250YWluZXJGaXhlZDogTmJCb29sZWFuSW5wdXQ7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCBzaWRlYmFyIHN0YXRlLCBgZXhwYW5kZWRgfGBjb2xsYXBzZWRgfGBjb21wYWN0ZWRgXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgc3RhdGUodmFsOiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIE1ha2VzIHNpZGViYXIgbGlzdGVuIHRvIG1lZGlhIHF1ZXJ5IGV2ZW50cyBhbmQgY2hhbmdlIGl0cyBiZWhhdmlvdXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgcmVzcG9uc2l2ZSh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yZXNwb25zaXZlOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBUYWdzIGEgc2lkZWJhciB3aXRoIHNvbWUgSUQsIGNhbiBiZSBsYXRlciB1c2VkIGluIHRoZSBzaWRlYmFyIHNlcnZpY2VcbiAgICAgKiB0byBkZXRlcm1pbmUgd2hpY2ggc2lkZWJhciB0cmlnZ2VyZWQgdGhlIGFjdGlvbiwgaWYgbXVsdGlwbGUgc2lkZWJhcnMgZXhpc3Qgb24gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRhZzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIG9uIHdoaWNoIHNjcmVlbiBzaXplcyBzaWRlYmFyIHNob3VsZCBiZSBzd2l0Y2hlZCB0byBjb21wYWN0ZWQgc3RhdGUuXG4gICAgICogV29ya3Mgb25seSB3aGVuIHJlc3BvbnNpdmUgbW9kZSBpcyBvbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlcyBhcmUgYFsneHMnLCAnaXMnLCAnc20nLCAnbWQnLCAnbGcnXWAuXG4gICAgICpcbiAgICAgKiBAdHlwZSBzdHJpbmdbXVxuICAgICAqL1xuICAgIGNvbXBhY3RlZEJyZWFrcG9pbnRzOiBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyBvbiB3aGljaCBzY3JlZW4gc2l6ZXMgc2lkZWJhciBzaG91bGQgYmUgc3dpdGNoZWQgdG8gY29sbGFwc2VkIHN0YXRlLlxuICAgICAqIFdvcmtzIG9ubHkgd2hlbiByZXNwb25zaXZlIG1vZGUgaXMgb24uXG4gICAgICogRGVmYXVsdCB2YWx1ZXMgYXJlIGBbJ3hzJywgJ2lzJ11gLlxuICAgICAqXG4gICAgICogQHR5cGUgc3RyaW5nW11cbiAgICAgKi9cbiAgICBjb2xsYXBzZWRCcmVha3BvaW50czogc3RyaW5nW107XG4gICAgcHJpdmF0ZSBtZWRpYVF1ZXJ5U3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgcmVzcG9uc2l2ZVN0YXRlO1xuICAgIGNvbnN0cnVjdG9yKHNpZGViYXJTZXJ2aWNlOiBOYlNpZGViYXJTZXJ2aWNlLCB0aGVtZVNlcnZpY2U6IE5iVGhlbWVTZXJ2aWNlLCBlbGVtZW50OiBFbGVtZW50UmVmKTtcbiAgICB0b2dnbGVSZXNwb25zaXZlKGVuYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IGFueSk6IHZvaWQ7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIG9uQ2xpY2soZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgY29sbGFwc2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgZXhwYW5kKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdHMgdGhlIHNpZGViYXIgKG1pbmltaXplcylcbiAgICAgKi9cbiAgICBjb21wYWN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBzaWRlYmFyIHN0YXRlIChleHBhbmRlZHxjb2xsYXBzZWR8Y29tcGFjdGVkKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcGFjdCBJZiB0cnVlLCB0aGVuIHNpZGViYXIgc3RhdGUgd2lsbCBiZSBjaGFuZ2VkIGJldHdlZW4gZXhwYW5kZWQgJiBjb21wYWN0ZWQsXG4gICAgICogb3RoZXJ3aXNlIC0gYmV0d2VlbiBleHBhbmRlZCAmIGNvbGxhcHNlZC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIFRvZ2dsZSBzaWRlYmFyIHN0YXRlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHRoaXMuc2lkZWJhci50b2dnbGUodHJ1ZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdG9nZ2xlKGNvbXBhY3Q/OiBib29sZWFuKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgb25NZWRpYVF1ZXJ5Q2hhbmdlcygpOiBTdWJzY3JpcHRpb247XG4gICAgcHJvdGVjdGVkIHJlc3BvbnNpdmVFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGdldE1lbnVMaW5rKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG4iXX0=